/**
 * OpenAPI Generator
 * Generates OpenAPI 3.0 specifications from discovered API routes
 */

class OpenAPIGenerator {
  constructor(apiLoader) {
    this.apiLoader = apiLoader;
  }

  /**
   * Generate OpenAPI specification
   */
  generateSpec() {
    const routes = this.apiLoader.getRoutes();
    const paths = this.generatePaths(routes);
    const components = this.generateComponents();
    
    return {
      openapi: '3.0.0',
      info: this.generateInfo(),
      servers: this.generateServers(),
      paths: paths,
      components: components,
      tags: this.generateTags(routes)
    };
  }

  /**
   * Generate paths object from routes
   */
  generatePaths(routes) {
    const paths = {};
    
    routes.forEach(route => {
      if (!paths[route.path]) {
        paths[route.path] = {};
      }
      
      const processor = route.processorInstance;
      const method = route.method.toLowerCase();
      
      if (processor) {
        // Build API info with available properties
        const apiInfo = {
          summary: `${route.method} ${route.path}`,
          tags: ['api'],
          operationId: `${method}_${route.path.replace(/\//g, '_').replace(/^_/, '')}`
        };
        
        // Add description if available
        if (processor.description) {
          apiInfo.description = processor.description;
        }
        
        // Add custom OpenAPI info if available
        if (processor.openApi) {
          Object.assign(apiInfo, processor.openApi);
        }
        
        // Auto-generate response schemas if not provided via annotations
        if (!apiInfo.responses) {
          apiInfo.responses = this.generateResponseSchema(processor);
        } else {
          // Only add auto-generated schemas for missing status codes
          const autoGeneratedResponses = this.generateResponseSchema(processor);
          Object.keys(autoGeneratedResponses).forEach(statusCode => {
            if (!apiInfo.responses[statusCode]) {
              apiInfo.responses[statusCode] = autoGeneratedResponses[statusCode];
            }
          });
        }
        
        // Add default error responses if not provided
        if (!apiInfo.responses['400']) {
          apiInfo.responses['400'] = {
            description: 'Bad request',
            content: {
              'application/json': {
                schema: {
                  $ref: '#/components/schemas/Error'
                }
              }
            }
          };
        }
        
        if (!apiInfo.responses['500']) {
          apiInfo.responses['500'] = {
            description: 'Internal server error',
            content: {
              'application/json': {
                schema: {
                  $ref: '#/components/schemas/Error'
                }
              }
            }
          };
        }
        
        paths[route.path][method] = apiInfo;
      } else {
        paths[route.path][method] = {
          summary: `${route.method} ${route.path}`,
          tags: ['api'],
          operationId: `${method}_${route.path.replace(/\//g, '_').replace(/^_/, '')}`,
          responses: {
            '200': {
              description: 'Successful response',
              content: {
                'application/json': {
                  schema: {
                    $ref: '#/components/schemas/Success'
                  }
                }
              }
            }
          }
        };
      }
    });
    
    return paths;
  }

  /**
   * Generate API info
   */
  generateInfo() {
    const packageJson = require('../../package.json');
    return {
      title: 'Easy MCP Framework',
      version: packageJson.version,
      description: 'A dynamic API framework with easy MCP (Model Context Protocol) integration for AI models. Includes LLM.txt support for AI model context.',
      contact: {
        name: 'API Support',
        url: 'https://github.com/easynet-world/easy-mcp-server'
      },
      license: {
        name: 'MIT',
        url: 'https://opensource.org/licenses/MIT'
      },
      externalDocs: {
        description: 'LLM.txt - AI Model Context',
        url: '/LLM.txt'
      }
    };
  }

  /**
   * Generate servers configuration
   */
  generateServers() {
    const port = process.env.SERVER_PORT || 3000;
    const host = process.env.SERVER_HOST || 'localhost';
    
    return [
      {
        url: `http://${host}:${port}`,
        description: 'Development server'
      },
      {
        url: `https://${host}:${port}`,
        description: 'Production server (HTTPS)'
      }
    ];
  }

  /**
   * Generate components (schemas, etc.)
   */
  generateComponents() {
    return {
      schemas: {
        Error: {
          type: 'object',
          required: ['success', 'error', 'timestamp'],
          properties: {
            success: { 
              type: 'boolean', 
              example: false,
              description: 'Operation success status'
            },
            error: { 
              type: 'string', 
              example: 'Error message',
              description: 'Error description'
            },
            timestamp: { 
              type: 'string', 
              format: 'date-time',
              description: 'Error timestamp'
            }
          }
        },
        Success: {
          type: 'object',
          required: ['success', 'timestamp'],
          properties: {
            success: { 
              type: 'boolean', 
              example: true,
              description: 'Operation success status'
            },
            data: { 
              type: 'object',
              description: 'Response data'
            },
            timestamp: { 
              type: 'string', 
              format: 'date-time',
              description: 'Response timestamp'
            }
          }
        },
        APIResponse: {
          type: 'object',
          properties: {
            success: { 
              type: 'boolean',
              description: 'Operation success status'
            },
            data: { 
              type: 'object',
              description: 'Response data'
            },
            message: { 
              type: 'string',
              description: 'Response message'
            },
            timestamp: { 
              type: 'string', 
              format: 'date-time',
              description: 'Response timestamp'
            }
          }
          // Additional properties can be added dynamically based on route schemas
        }
      },
      securitySchemes: {
        // Add security schemes if needed
      }
    };
  }

  /**
   * Generate tags for API grouping
   */
  generateTags(routes) {
    const tags = [
      {
        name: 'api',
        description: 'Dynamic API endpoints'
      }
    ];
    
    // Extract unique tags from routes
    const routeTags = new Set();
    routes.forEach(route => {
      if (route.processorInstance?.openApi?.tags) {
        route.processorInstance.openApi.tags.forEach(tag => routeTags.add(tag));
      }
    });
    
    routeTags.forEach(tag => {
      tags.push({
        name: tag,
        description: `${tag} related endpoints`
      });
    });
    
    return tags;
  }

  /**
   * Auto-generate response schema by analyzing the processor
   * @param {Object} processor - The API processor instance
   * @returns {Object} OpenAPI response schema
   */
  generateResponseSchema(processor) {
    try {
      // Try to get a sample response by calling the process method with mock data
      const mockReq = {
        body: {},
        query: {},
        params: {},
        headers: {}
      };
      
      const mockRes = {
        json: (data) => {
          // Capture the response data
          mockRes.responseData = data;
        },
        status: (code) => {
          mockRes.statusCode = code;
          return mockRes;
        }
      };

      // Call the process method to get sample response
      if (typeof processor.process === 'function') {
        processor.process(mockReq, mockRes);
        
        if (mockRes.responseData) {
          return this.generateSchemaFromData(mockRes.responseData);
        }
      }
    } catch (error) {
      console.warn(`Warning: Could not auto-generate schema for ${processor.constructor.name}:`, error.message);
    }

    // Fallback to default success response
    return {
      '200': {
        description: 'Successful response',
        content: {
          'application/json': {
            schema: {
              $ref: '#/components/schemas/Success'
            }
          }
        }
      }
    };
  }

  /**
   * Generate OpenAPI schema from response data
   * @param {*} data - The response data
   * @returns {Object} OpenAPI response schema
   */
  generateSchemaFromData(data) {
    const schema = this.inferSchemaType(data);
    
    return {
      '200': {
        description: 'Successful response',
        content: {
          'application/json': {
            schema: schema
          }
        }
      }
    };
  }

  /**
   * Infer OpenAPI schema type from data
   * @param {*} data - The data to analyze
   * @returns {Object} OpenAPI schema object
   */
  inferSchemaType(data) {
    if (data === null) {
      return { type: 'null' };
    }
    
    if (Array.isArray(data)) {
      if (data.length === 0) {
        return { type: 'array', items: {} };
      }
      return {
        type: 'array',
        items: this.inferSchemaType(data[0])
      };
    }
    
    if (typeof data === 'object') {
      const properties = {};
      const required = [];
      
      for (const [key, value] of Object.entries(data)) {
        properties[key] = this.inferSchemaType(value);
        
        // Consider primitive values as required
        if (value !== null && value !== undefined && typeof value !== 'object') {
          required.push(key);
        }
      }
      
      return {
        type: 'object',
        properties,
        required: required.length > 0 ? required : undefined
      };
    }
    
    // Handle primitive types
    switch (typeof data) {
    case 'string':
      return { type: 'string' };
    case 'number':
      return Number.isInteger(data) ? { type: 'integer' } : { type: 'number' };
    case 'boolean':
      return { type: 'boolean' };
    default:
      return { type: 'string' };
    }
  }
}

module.exports = OpenAPIGenerator;
